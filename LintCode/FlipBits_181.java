public class Solution {
    /**
     * @param a: An integer
     * @param b: An integer
     * @return: An integer
     */
    public int bitSwapRequired(int a, int b) {
        // write your code here
        
        /*
            移位，然后遇到1计数器加1。
            但是需要注意终止条件，正数循环移位会得到0，负数并不是这样，会得到1000…000，
            也就是-2**31。因为Java/Python中整数是以32个bit位存储的，第1位是符号位，31位是值。
            所以我们的移位操作最多进行31次，这个信息也可以做为循环中止条件。
            
            1. 奇数的话，减去1成偶数，二进制形式中，只有最后一位不同（由1变为0）。
            例如：5：101，4：100

            2. 偶数的话，减去1成奇数，二进制形式中，偶数尾巴上的所有0（直到倒数第一个1为止），
            全部变为1，且倒数第一个1变为0. 例如：142：10100000；141：10011111
            
            用“与”运算可以产生的效果：不论是奇数还是偶数，“与”运算之后，
            都会是原先的数的二进制中少一个1.
            
            循环，每次都和减1的值做“与”运算，直到结果等于0，统计循环的次数，就能知道有多少1.
            
            需要注意的是正负数的二进制问题。这里，先普及一下负数的二进制是如何生成的，分两步：

            1. 取反：就是对这个负数的绝对值按位取反，得到的叫做反码（比如，要计算-2的二进制，就要先对2的二进制按位取反）

            2. 加1：取反后，对这个二进制数加1，得到的叫做补码

            比如，-24，先对24（二进制数：11000）取反，得到00111；再加1，得到01000

            所以，我们设一个负数是a，显然，a - 1的二进制表示就是-a的反码。
            而用32减去(-a)中1的个数就是(a - 1)中1的个数。
            因此，求一个负数的二进制中1的个数，可以先对这个数（把他看做a - 1）加1，记为b，
            再求b的绝对值的二进制表示的1的个数，记为n，32 - n就是最后的答案。
        */
        int c = a ^ b;
        int count = 0;
        
        while (c != 0) {
            c = c & (c - 1);
            count ++;
        }
        
        return count;
    }
}